{"title":"$:/plugins/wikilabs/custom-markup","name":"Custom Markup","description":"Adds a possibilty to style text content with wikitext syntax","list":"readme license history","version":"0.8.0","plugin-type":"plugin","dependents":"","type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/config/custom-markup/pragma/PageTemplate\": {\n            \"title\": \"$:/config/custom-markup/pragma/PageTemplate\",\n            \"tags\": \"$:/tags/PageTemplate\",\n            \"text\": \"\\\\importcustom [tag[$:/tags/Pragma]]\"\n        },\n        \"$:/config/ShortcutInfo/add-angle\": {\n            \"title\": \"$:/config/ShortcutInfo/add-angle\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"{{$:/plugins/wikilabs/custom-markup/EditorToolbar/add-angle!!description}}\"\n        },\n        \"$:/config/ShortcutInfo/add-newline\": {\n            \"title\": \"$:/config/ShortcutInfo/add-newline\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"{{$:/plugins/wikilabs/custom-markup/EditorToolbar/add-newline!!description}}\"\n        },\n        \"$:/config/ShortcutInfo/remove-angle\": {\n            \"title\": \"$:/config/ShortcutInfo/remove-angle\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"{{$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-angle!!description}}\"\n        },\n        \"$:/config/ShortcutInfo/remove-custom-markers\": {\n            \"title\": \"$:/config/ShortcutInfo/remove-custom-markers\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"{{$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-custom-markers!!description}}\"\n        },\n        \"$:/config/ShortcutInfo/toggle-tick\": {\n            \"title\": \"$:/config/ShortcutInfo/toggle-tick\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"{{$:/plugins/wikilabs/custom-markup/EditorToolbar/toggle-tick!!description}}\"\n        },\n        \"$:/config/shortcuts/add-angle\": {\n            \"title\": \"$:/config/shortcuts/add-angle\",\n            \"tags\": \"\",\n            \"text\": \"ctrl-7\"\n        },\n        \"$:/config/shortcuts/add-newline\": {\n            \"title\": \"$:/config/shortcuts/add-newline\",\n            \"tags\": \"\",\n            \"text\": \"ctrl-shift-Enter\"\n        },\n        \"$:/config/shortcuts/remove-angle\": {\n            \"title\": \"$:/config/shortcuts/remove-angle\",\n            \"tags\": \"\",\n            \"text\": \"ctrl-6\"\n        },\n        \"$:/config/shortcuts/remove-custom-markers\": {\n            \"title\": \"$:/config/shortcuts/remove-custom-markers\",\n            \"tags\": \"\",\n            \"text\": \"ctrl-8\"\n        },\n        \"$:/config/shortcuts/toggle-tick\": {\n            \"title\": \"$:/config/shortcuts/toggle-tick\",\n            \"tags\": \"\",\n            \"text\": \"ctrl-9\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/notify/id-prepared\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/notify/id-prepared\",\n            \"text\": \"ID Button prepared!<br>\\nContent copied to clipboard!\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/add-angle\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/add-angle\",\n            \"caption\": \"add-angle\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"description\": \"Add a \\\"angle bracket\\\" at the start of the selected line(s)\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/angle-plus\",\n            \"shortcuts\": \"((add-angle))\",\n            \"tags\": \"$:/tags/EditorToolbar\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"add-tick\\\"\\n\\tcharacter=\\\"»\\\"\\n\\tcount=\\\"1\\\"\\n/>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/add-newline\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/add-newline\",\n            \"caption\": \"add-newline\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"description\": \"Adds a newline character at the end of the selected line(s)\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/add-newline\",\n            \"shortcuts\": \"((add-newline))\",\n            \"tags\": \"$:/tags/EditorToolbar\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"add-newline\\\"\\n\\tcharacter=\\\"\\n\\\"\\n\\tcount=\\\"1\\\"\\n/>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/add-tick\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/add-tick\",\n            \"caption\": \"add-tick\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"created\": \"20200830145744005\",\n            \"description\": \"Add a \\\"tick\\\" at the start of the selected line(s)\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/tick-plus\",\n            \"modified\": \"20200913204237400\",\n            \"shortcuts\": \"((add-tick))\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"add-tick\\\"\\n\\tcharacter={{{ [[$:/config/edit/linePrefix]get[text]] }}}\\n\\tcount=\\\"1\\\"\\n/>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/prefix-dropdown\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/prefix-dropdown\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"\\\\define selectActions()\\n<$action-createtiddler $basetitle=\\\"$:/config/edit/linePrefix\\\" $overwrite=\\\"yes\\\" \\n    text={{{ [<linePrefix>get[text]] }}}\\n    name=\\\"\\\"\\\"$(linePrefix)$\\\"\\\"\\\" \\n    id={{{ [<linePrefix>get[id]]~´ }}}\\n/>\\n<$action-sendmessage $message=\\\"tm-copy-to-clipboard\\\" $param={{{ [{$:/config/edit/linePrefix!!id}addsuffix{$:/config/edit/linePrefix!!text}] }}}/>\\n<$action-sendmessage $message=\\\"tm-notify\\\" $param=\\\"$:/plugins/wikilabs/custom-markup/EditorToolbar/notify/id-prepared\\\"/>\\n<$action-deletetiddler $tiddler=<<dropdown-state>> />\\n\\\\end\\n\\\\define idSelector()\\n<$tiddler tiddler=\\\"$:/config/edit/linePrefix\\\">\\n  <$radio field=\\\"id\\\" value=\\\"›\\\"> › </$radio>|\\n  <$radio field=\\\"id\\\" value=\\\"´\\\"> ´ </$radio>|\\n  <$radio field=\\\"id\\\" value=\\\"°\\\"> ° </$radio>|\\n  <$radio field=\\\"id\\\" value=\\\"»\\\"> » </$radio>|\\n  <$radio field=\\\"id\\\" value=\\\"≈\\\"> ≈ </$radio>|\\n  <$checkbox \\n     field=force\\n     checked=\\\"yes\\\"\\n     unchecked=\\\"no\\\"\\n     default=\\\"no\\\" > Use all lines</$checkbox>\\n</$tiddler>\\n\\\\end\\n\\\\define preview-type-button()\\n<$button tag=\\\"a\\\" actions=<<selectActions>> >\\n\\n<$transclude tiddler=<<linePrefix>> field=\\\"caption\\\" mode=\\\"inline\\\">\\n\\n<$view tiddler=<<linePrefix>> field=\\\"title\\\" mode=\\\"inline\\\"/>\\n\\n</$transclude> \\n\\n<$reveal tag=\\\"span\\\" stateTitle=\\\"$:/config/edit/linePrefix\\\" stateField=name type=\\\"match\\\" text=<<linePrefix>> default=\\\"XXXXX\\\">\\n\\n<$entity entity=\\\"&nbsp;\\\"/>\\n\\n<$entity entity=\\\"&#x2713;\\\"/>\\n\\n</$reveal>\\n\\n</$button>\\n\\\\end\\n\\nSelect ID -- <$macrocall $name=idSelector />\\n\\n----\\n\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/TextEditor/LinePrefix]!has[draft.of]sort[title]]\\\" variable=\\\"linePrefix\\\">\\n\\n<<preview-type-button>>\\n\\n</$list>\\n\\n----\\n\\n<$button tag=\\\"a\\\">\\n\\n<$action-sendmessage\\n\\t$message=\\\"tm-new-tiddler\\\"\\n\\ttags=\\\"$:/tags/TextEditor/LinePrefix\\\"\\n\\tcaption=\\\"New Line Prefix\\\"\\n\\ttext=\\\"\\\"\\n/>\\n\\n<$action-deletetiddler \\n\\t$tiddler=<<dropdown-state>> \\n/>\\n\\n<em>\\n\\n<$text text={{$:/language/Buttons/Stamp/Caption/New}}/>\\n\\n</em>\\n\\n</$button>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/preview-type\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/preview-type\",\n            \"button-classes\": \"tc-text-editor-toolbar-item-adjunct\",\n            \"caption\": \"Choose ID type\",\n            \"condition\": \"[all[shadows+tiddlers]tag[$:/tags/EditPreview]!has[draft.of]butfirst[]limit[1]]\",\n            \"description\": \"Choose ID type\",\n            \"dropdown\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/prefix-dropdown\",\n            \"icon\": \"$:/core/images/chevron-down\",\n            \"tags\": \"$:/tags/EditorToolbar\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-angle\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-angle\",\n            \"caption\": \"remove-angle\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"description\": \"Remove a \\\"angle bracket\\\" at the start of the selected line(s)\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/angle-minus\",\n            \"shortcuts\": \"((remove-angle))\",\n            \"tags\": \"$:/tags/EditorToolbar\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"remove-tick\\\"\\n\\tcharacter=\\\"»\\\"\\n\\tcount=\\\"1\\\"\\n/>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-custom-markers\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-custom-markers\",\n            \"caption\": \"remove-markers\",\n            \"tags\": \"$:/tags/EditorToolbar\",\n            \"shortcuts\": \"((remove-custom-markers))\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/custom-minus-all\",\n            \"description\": \"Remove every \\\"custom marker\\\" from the selected line(s)\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"remove-custom-markers\\\"\\n\\tcharacter=\\\"*\\\"\\n\\tcount=\\\"1\\\"\\n/>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-tick\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/remove-tick\",\n            \"caption\": \"remove-tick\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"created\": \"20200830155036038\",\n            \"description\": \"Remove a \\\"tick\\\" at the start of the selected line(s)\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/tick-minus\",\n            \"modified\": \"20200914083802568\",\n            \"shortcuts\": \"((remove-tick))\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"remove-tick\\\"\\n\\tcharacter=\\\"´\\\"\\n\\tcount=\\\"1\\\"\\n/>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/EditorToolbar/toggle-tick\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/EditorToolbar/toggle-tick\",\n            \"caption\": \"toggle-ID\",\n            \"condition\": \"[<targetTiddler>!has[type]] [<targetTiddler>type[text/vnd.tiddlywiki]]\",\n            \"description\": \"Toggle the \\\"ID\\\" at the start of the selected line(s)\",\n            \"icon\": \"$:/plugins/wikilabs/custom-markup/icons/tick-toggle\",\n            \"shortcuts\": \"((toggle-tick))\",\n            \"tags\": \"$:/tags/EditorToolbar\",\n            \"text\": \"<$action-sendmessage\\n\\t$message=\\\"tm-edit-text-operation\\\"\\n\\t$param=\\\"toggle-tick\\\"\\n\\tcharacter={{{ [{$:/config/edit/linePrefix!!id}addsuffix{$:/config/edit/linePrefix!!text}] }}}\\n\\tcount=\\\"1\\\"\\n\\tforce={{{ [{$:/config/edit/linePrefix!!force}] }}}\\n/>\\n\"\n        },\n        \"$:/tags/EditorToolbar\": {\n            \"title\": \"$:/tags/EditorToolbar\",\n            \"created\": \"20200830174644399\",\n            \"list\": \"$:/core/ui/EditorToolbar/paint $:/core/ui/EditorToolbar/opacity $:/core/ui/EditorToolbar/line-width $:/core/ui/EditorToolbar/rotate-left $:/core/ui/EditorToolbar/clear $:/core/ui/EditorToolbar/bold $:/core/ui/EditorToolbar/italic $:/core/ui/EditorToolbar/strikethrough $:/core/ui/EditorToolbar/underline $:/core/ui/EditorToolbar/superscript $:/core/ui/EditorToolbar/subscript $:/core/ui/EditorToolbar/mono-line $:/core/ui/EditorToolbar/linkify $:/core/ui/EditorToolbar/transcludify $:/core/ui/EditorToolbar/mono-block $:/core/ui/EditorToolbar/quote $:/core/ui/EditorToolbar/list-bullet $:/core/ui/EditorToolbar/list-number $:/core/ui/EditorToolbar/heading-1 $:/core/ui/EditorToolbar/heading-2 $:/core/ui/EditorToolbar/heading-3 $:/core/ui/EditorToolbar/heading-4 $:/core/ui/EditorToolbar/heading-5 $:/core/ui/EditorToolbar/heading-6 $:/core/ui/EditorToolbar/link $:/core/ui/EditorToolbar/excise $:/core/ui/EditorToolbar/picture $:/core/ui/EditorToolbar/stamp $:/core/ui/EditorToolbar/size $:/core/ui/EditorToolbar/editor-height $:/core/ui/EditorToolbar/more $:/core/ui/EditorToolbar/preview $:/core/ui/EditorToolbar/preview-type $:/plugins/wikilabs/custom-markup/EditorToolbar/add-newline $:/plugins/wikilabs/custom-markup/EditorToolbar/remove-angle $:/plugins/wikilabs/custom-markup/EditorToolbar/add-angle $:/plugins/wikilabs/custom-markup/EditorToolbar/remove-custom-markers $:/plugins/wikilabs/custom-markup/EditorToolbar/toggle-tick $:/plugins/wikilabs/custom-markup/EditorToolbar/preview-type\",\n            \"modified\": \"20200915223100053\",\n            \"type\": \"text/vnd.tiddlywiki\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/history-short\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/history-short\",\n            \"text\": \"\\nV 0.8.1 - 2020-10-30\\n\\n* fix `/°slash /°slash nesting°/ nesting°/`\\n\\nV 0.8.0 - 2020-10-29\\n\\n* There are 4 \\\"inline\\\" elements\\n** `__ underscore__`, `﹙ little﹚`, `⠒ braille⠶`, `/° slash°/`\\n* There are 6 \\\"block\\\" elements\\n** `pilcrow: ¶`, `about: ≈`, `angle: »`, `degree: °`, `tick: ´`, `single: ›`\\n\\nSee [[full history|$:/plugins/wikilabs/custom-markup/history]]\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/history\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/history\",\n            \"text\": \"\\n{{$:/plugins/wikilabs/custom-markup/history-short}}\\n\\nV 0.7.0 - 2020-10-23\\n\\n* New Inline functions\\n** `_symbol.class.clsss:param:param some text__`\\n** `.class` and `:param` work the same way as \\\"block\\\" definitions\\n* Removed underscore from \\\"block\\\" definitions, because it's used by \\\"inline\\\"\\n* Added: `\\\\\\\\ pragma comments`\\n** It's faster than HTML comments `<!-- comments -->`, since it can be used outside macro `\\\\define x()` blocks\\n\\nV 0.6.0 - 2020-10-03\\n\\n* ''New Functionality''\\n** $:/config/custom-markup/pragma/PageTemplate tagged: `$:/tags/Macro`\\n*** content: `\\\\importcustom [tag[$:/tags/Pragma]]`\\n** contains global pragma definitions .. and macro definitions\\n\\n* ''Incompatible changes''\\n** `_params` renamed to -> `_classes`\\n** `_maps` renamed to -> `_params` !!\\n** Adjusted the docs accordingly\\n* Improved debug modes\\n** `\\\\debugcustomize` new parameters: `no`, `list`, `global`, `global list`, `global ID`\\n** `_debug` new parameter: `no`,\\n* `angel` renamed to: `angle` + docs\\n\\nV 0.5.3 - 2020-09-29\\n\\n* new parameters: `_1, _2, _maps`\\n** allows `°:param1Text:param2Text` \\n** new format `°.i.x.y:a:b`\\n* [[Examples + Reference|https://wikilabs.github.io/editions/custom-markup/#test-checkbox-widget-maps-transclusion:test-checkbox-widget-maps-transclusion test-checkbox-widget-maps-variable \\\"Custom Markup Definition\\\"]]\\n\\nV 0.5.2 - 2020-09-23\\n\\n* fixed \\\\importcustom\\n* new parameter _srcName\\n* \\\\customize or \\\\customise can be used\\n* \\\\debugcustomize or \\\\debugcustomise can be used\\n\\nV 0.5.0 - 2020.09.20\\n\\n* New Plugin Name: custom-markup\\n* New directory structure\\n\\nV 0.4.2 - 2020-09-18\\n\\n* docs is on the way\\n* almost feature complete\\n** \\\\custominline needs to be improved\\n\\nV 0.4.0 2020.09.16\\n\\n* added IDs: single \\\"›\\\" and almost \\\"≈\\\"\\n* ID comma removed \\n* new toolbar buttons\\n* new keyboard shortcuts\\n\\nV 0.3.0 2020.09.10\\n\\n* pragma parameters renamed to _element, _use, _mode, ... \\n** because there was a naming problem with widget parameters\\n* tick-inline uses `°°` now\\n\\nV 0.2.1 2020-09.12\\n\\n* add more IDs comma, degree, underline\\n* \\\\ticktect becomes \\\\customize\\n* \\\\tickdebug becomes \\\\debugcustomize\\n\\nV 0.0.1 - 2020-08-28\\n\\n* initial release\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/add-newline\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/add-newline\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\">\\n <path d=\\\"m0.242 22.8h85.3v11.6h-85.3zm0 34.9h85.3v11.6h-85.3v-11.6zm0 34.9h85.3v11.6h-85.3z\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\".957\\\"/>\\n <path d=\\\"m111 47.7-21.2-8.94 21.2-9.35v5.15l9.98 3e-6 0.0422-21.9 7.26-0.0267-0.0287 29.9h-17.2z\\\" />\\n <path d=\\\"m111 82.3-21.2-8.94 21.2-9.35v5.15l9.98 3e-6 0.0422-21.9 7.26-0.0267-0.0287 29.9h-17.2z\\\" />\\n <path d=\\\"m111 117-21.2-8.94 21.2-9.35v5.15l9.98 1e-5 0.0422-21.9 7.26-0.0267-0.0287 29.9h-17.2z\\\" />\\n </svg>\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/angle-minus\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/angle-minus\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\"> <g fill-rule=\\\"evenodd\\\">\\n <path d=\\\"m69.256 51.81h47.566v11.636h-47.566v-11.637z\\\" fill-rule=\\\"evenodd\\\"/>\\n <g transform=\\\"matrix(1.5813 0 0 1.5813 -11.86 -48.2)\\\" stroke-width=\\\"1.02\\\">\\n  <path d=\\\"m11.382 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n  <path d=\\\"m23.054 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n </g>\\n <g transform=\\\"matrix(1.5813 0 0 1.5813 -11.86 7.9787)\\\" stroke-width=\\\"1.02\\\">\\n  <path d=\\\"m11.382 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n  <path d=\\\"m23.054 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n </g>\\n</svg>\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/angle-plus\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/angle-plus\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\"> <g fill-rule=\\\"evenodd\\\">\\n <g transform=\\\"matrix(1.0801 0 0 1.0801 4.212 -17.516)\\\" fill-rule=\\\"evenodd\\\">\\n  <path d=\\\"m57.573 69.333h47.566v11.636h-47.566v-11.637z\\\"/>\\n  <path d=\\\"m87.174 51.368v47.566h-11.636v-47.566h11.637z\\\"/>\\n </g>\\n <g transform=\\\"matrix(1.7079 0 0 1.7079 -14.41 -51.918)\\\" stroke-width=\\\"1.02\\\">\\n  <path d=\\\"m11.382 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n  <path d=\\\"m23.054 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n </g>\\n <g transform=\\\"matrix(1.7079 0 0 1.7079 -14.41 9.7276)\\\" stroke-width=\\\"1.02\\\">\\n  <path d=\\\"m11.382 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n  <path d=\\\"m23.054 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n </g>\\n</svg>\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/custom-minus-all\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/custom-minus-all\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\">\\n <g fill-rule=\\\"evenodd\\\">\\n  <path d=\\\"m7.3709 38.298 19.404-15.446-15.139-5.8519-11.427 17.159z\\\"/>\\n  <path d=\\\"m7.2811 73.472 19.404-15.446-15.139-5.8519-11.427 17.159z\\\"/>\\n  <path d=\\\"m7.3709 108.27 19.404-15.446-15.139-5.8519-11.427 17.159zm51.424-34.072h47.566v11.636h-47.566v-11.637z\\\"/>\\n </g>\\n <g>\\n  <path d=\\\"m62.307 8.9688-9.3409 25.33h18.716zm-3.8864-6.7841h7.8068l19.398 50.898h-7.1591l-4.6364-13.057h-22.943l-4.6364 13.057h-7.2614z\\\" style=\\\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\\\"/>\\n  <path d=\\\"m92.751 0.036991h6.2727v53.045h-6.2727z\\\" style=\\\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\\\"/>\\n  <path d=\\\"m121.38 0.036991h6.2727v53.045h-6.2727z\\\" style=\\\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\\\"/>\\n </g>\\n</svg>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/tick-minus\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/tick-minus\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\">\\n  <path d=\\\"m7.3709 38.298 19.404-15.446-15.139-5.8519-11.427 17.159zm27.539-15.48h93.09v11.637h-93.09z\\\"/>\\n  <path d=\\\"m7.2811 73.472 19.404-15.446-15.139-5.8519-11.427 17.159z\\\"/>\\n  <path d=\\\"m7.3709 108.27 19.404-15.446-15.139-5.8519-11.427 17.159zm51.424-34.072h47.566v11.636h-47.566v-11.637z\\\"/>\\n</svg>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/tick-plus\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/tick-plus\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\">\\n  <path d=\\\"m7.3709 38.298 19.404-15.446-15.139-5.8519-11.427 17.159zm27.539-15.48h93.09v11.637h-93.09zm41.682 34.833h12.391v46.476h-12.391z\\\"/>\\n  <path d=\\\"m7.2811 73.472 19.404-15.446-15.139-5.8519-11.427 17.159z\\\"/>\\n  <path d=\\\"m7.3709 108.27 19.404-15.446-15.139-5.8519-11.427 17.159zm51.424-34.072h47.566v11.636h-47.566v-11.637z\\\"/>\\n</svg>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/tick-toggle\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/tick-toggle\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\">\\n <g transform=\\\"translate(0 16.058)\\\" fill-rule=\\\"evenodd\\\">\\n  <path d=\\\"m61.715 61.724h47.566v11.636h-47.566v-11.637z\\\"/>\\n  <path d=\\\"m91.149 43.583v47.566h-11.636v-47.566h11.637z\\\"/>\\n </g>\\n <g fill-rule=\\\"evenodd\\\">\\n  <path d=\\\"m11.228 56.264 30.441-24.231-23.75-9.1806-17.927 26.919z\\\" stroke-width=\\\"1.5688\\\"/>\\n  <path d=\\\"m11.35 106.77 30.441-24.231-23.75-9.1806-17.927 26.919z\\\" stroke-width=\\\"1.5688\\\"/>\\n  <path d=\\\"m61.296 27.452h47.566v11.636h-47.566v-11.637z\\\"/>\\n </g>\\n</svg>\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/angle-toggle\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/angle-toggle\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\"> <g fill-rule=\\\"evenodd\\\">\\n <g transform=\\\"translate(5.9262 6.1069)\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\"1.08\\\">\\n  <path d=\\\"m64.778 72.157h51.374v12.567h-51.374v-12.569z\\\"/>\\n  <path d=\\\"m96.748 52.753v51.374h-12.567v-51.374h12.569z\\\"/>\\n </g>\\n <g transform=\\\"matrix(1.7079 0 0 1.7079 -14.41 -51.918)\\\" stroke-width=\\\"1.02\\\">\\n  <path d=\\\"m11.382 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n  <path d=\\\"m23.054 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n </g>\\n <g transform=\\\"matrix(1.7079 0 0 1.7079 -14.41 9.7276)\\\" stroke-width=\\\"1.02\\\">\\n  <path d=\\\"m11.382 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n  <path d=\\\"m23.054 64.208-2.6718-2.6321 12.724-12.766-12.471-12.505 2.6539-2.6782 15.196 15.18z\\\"/>\\n </g>\\n <path d=\\\"m71.827 34.16h51.374v12.567h-51.374v-12.569z\\\" fill-rule=\\\"evenodd\\\" stroke-width=\\\"1.08\\\"/>\\n</svg>\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/icons/toggle-dot\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/icons/toggle-dot\",\n            \"text\": \"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-list-bullet tc-image-button\\\" viewBox=\\\"0 0 128 128\\\">\\n <path d=\\\"m34.91 22.818h93.09v11.637h-93.09zm0 34.91h93.09v11.636h-93.09v-11.637zm0 34.908h93.09v11.637h-93.09z\\\" fill-rule=\\\"evenodd\\\"/>\\n  <path d=\\\"m12.19 28.635a5.9048 5.9048 0 0 1-5.9048 5.9048 5.9048 5.9048 0 0 1-5.9048-5.9048 5.9048 5.9048 0 0 1 5.9048-5.9048 5.9048 5.9048 0 0 1 5.9048 5.9048z\\\"/>\\n  <path d=\\\"m12.063 63.175a5.9048 5.9048 0 0 1-5.9048 5.9048 5.9048 5.9048 0 0 1-5.9048-5.9048 5.9048 5.9048 0 0 1 5.9048-5.9048 5.9048 5.9048 0 0 1 5.9048 5.9048\\\"/>\\n  <path d=\\\"m12 98.286a5.9048 5.9048 0 0 1-5.9048 5.9048 5.9048 5.9048 0 0 1-5.9048-5.9048 5.9048 5.9048 0 0 1 5.9048-5.9048 5.9048 5.9048 0 0 1 5.9048 5.9048\\\"/>\\n </svg>\\n  \\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/license\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/license\",\n            \"text\": \"[[Custom Markup-Plugin|https://wikilabs.github.io/#custom-markup]] (c) Mario Pietsch - 2020-\\n\\nhttps://opensource.org/licenses/BSD-3-Clause\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/editor/operations/text/add-newline.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/editor/operations/text/add-newline.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/editor/operations/text/add-newline.js\\ntype: application/javascript\\nmodule-type: texteditoroperation\\n\\nText editor operation to add a prefix to the selected lines\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports[\\\"add-newline\\\"] = function(event,operation) {\\n\\tvar x = \\\"\\\";\\n\\tvar targetCount = parseInt(event.paramObject.count + \\\"\\\",10);\\n\\t// Cut just past the preceding line break, or the start of the text\\n\\toperation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);\\n\\t// Cut to just past the following line break, or to the end of the text\\n\\toperation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);\\n\\t// Compose the required prefix\\n\\tvar prefix = $tw.utils.repeat(event.paramObject.character,targetCount);\\n\\t// Process each line\\n\\tvar lines = operation.text.substring(operation.cutStart,operation.cutEnd).split(/\\\\r?\\\\n/mg);\\n\\t$tw.utils.each(lines,function(line,index) {\\n\\t\\t// Remove and count any existing prefix characters\\n\\t\\tvar count = 0;\\n//\\t\\twhile(line.charAt(0) === event.paramObject.character) {\\n//\\t\\t\\tline = line.substring(1);\\n//\\t\\t\\tcount++;\\n//\\t\\t\\tx += prefix;\\n//\\t\\t}\\n\\t\\t// Remove any whitespace\\n\\t\\twhile(line.charAt(0) === \\\" \\\") {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t}\\n\\t\\t// We're done if we removed the exact required prefix, otherwise add it\\n\\t\\t// Apply the prefix\\n\\t\\tline =  line + prefix;\\n//\\t\\t}\\n\\t\\t// Save the modified line\\n\\t\\tlines[index] = line;\\n\\t});\\n\\t// Stitch the replacement text together and set the selection\\n\\toperation.replacement = lines.join(\\\"\\\\n\\\");\\n\\tif(lines.length === 1) {\\n\\t\\toperation.newSelStart = operation.cutStart + operation.replacement.length;\\n\\t\\toperation.newSelEnd = operation.newSelStart;\\n\\t} else {\\n\\t\\toperation.newSelStart = operation.cutStart;\\n\\t\\toperation.newSelEnd = operation.newSelStart + operation.replacement.length;\\n\\t}\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"texteditoroperation\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/editor/operations/text/add-tick.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/editor/operations/text/add-tick.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/editor/operations/text/add-tick.js\\ntype: application/javascript\\nmodule-type: texteditoroperation\\n\\nText editor operation to add a prefix to the selected lines\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports[\\\"add-tick\\\"] = function(event,operation) {\\n\\tvar x=\\\"\\\";\\n\\tvar targetCount = parseInt(event.paramObject.count + \\\"\\\",10);\\n\\t// Cut just past the preceding line break, or the start of the text\\n\\toperation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);\\n\\t// Cut to just past the following line break, or to the end of the text\\n\\toperation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);\\n\\t// Compose the required prefix\\n\\tvar prefix = $tw.utils.repeat(event.paramObject.character,targetCount);\\n\\t// Process each line\\n\\tvar lines = operation.text.substring(operation.cutStart,operation.cutEnd).split(/\\\\r?\\\\n/mg);\\n\\t$tw.utils.each(lines,function(line,index) {\\n\\t\\t// Remove and count any existing prefix characters\\n\\t\\tvar count = 0\\n\\t\\t\\tx = \\\"\\\";\\n\\t\\twhile(line.charAt(0) === event.paramObject.character) {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t\\tcount++;\\n\\t\\t\\tx += prefix;\\n\\t\\t}\\n\\t\\t// Remove any whitespace\\n\\t\\twhile(line.charAt(0) === \\\" \\\") {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t}\\n\\t\\t// We're done if we removed the exact required prefix, otherwise add it\\n\\t\\t// Apply the prefix\\n\\t\\tline = x + prefix + \\\" \\\" + line;\\n//\\t\\t}\\n\\t\\t// Save the modified line\\n\\t\\tlines[index] = line;\\n\\t});\\n\\t// Stitch the replacement text together and set the selection\\n\\toperation.replacement = lines.join(\\\"\\\\n\\\");\\n\\tif(lines.length === 1) {\\n\\t\\toperation.newSelStart = operation.cutStart + operation.replacement.length;\\n\\t\\toperation.newSelEnd = operation.newSelStart;\\n\\t} else {\\n\\t\\toperation.newSelStart = operation.cutStart;\\n\\t\\toperation.newSelEnd = operation.newSelStart + operation.replacement.length;\\n\\t}\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"texteditoroperation\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/editor/operations/text/remove-custom-markers.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/editor/operations/text/remove-custom-markers.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/editor/operations/text/remove-custom-markers.js\\ntype: application/javascript\\nmodule-type: texteditoroperation\\n\\nText editor operation to add a prefix to the selected lines\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node:true, browser: true */\\n/*global $tw:false exports:false */\\n\\\"use strict\\\";\\n\\nexports[\\\"remove-custom-markers\\\"] = function(event,operation) {\\n\\t// regExp to detect custom markers like: \\n\\t// <ID><symol><class> some text\\n\\t// ´span.myClass.otherClass some text\\n\\tvar regExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›|(?=_[^_])_)((?:[^\\\\.\\\\r\\\\n\\\\s´°]+))?(\\\\.(?:[^\\\\r\\\\n\\\\s]+))?/mg;\\n\\t\\n\\tvar targetCount = parseInt(event.paramObject.count + \\\"\\\",10);\\n\\t// Cut just past the preceding line break, or the start of the text\\n\\toperation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);\\n\\t// Cut to just past the following line break, or to the end of the text\\n\\toperation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);\\n\\t// Compose the required prefix\\n\\tvar prefix = $tw.utils.repeat(event.paramObject.character,targetCount);\\n\\t// Process each line\\n\\tvar lines = operation.text.substring(operation.cutStart,operation.cutEnd).split(/\\\\r?\\\\n/mg);\\n\\t\\n\\tvar test = \\\"›´°_»≈\\\";\\n\\t\\n\\t$tw.utils.each(lines,function(line,index) {\\n\\t\\tvar fragments = line.split(\\\" \\\");\\n\\t\\t\\n\\t\\tvar match = fragments[0].match(regExp); \\n\\t\\t\\n\\t\\tif (match && (fragments[0] === match[0])) {\\n\\t\\t\\tline = fragments.slice(1).join(\\\" \\\");\\n\\t\\t} else if (!match && (test.indexOf(fragments[0]) !== -1)) {\\n\\t\\t\\tline = fragments.slice(1).join(\\\" \\\");\\n\\t\\t} else {\\n\\t\\t\\tline = fragments.join(\\\" \\\");\\n\\t\\t}\\n\\t\\t// Remove any whitespace\\n\\t\\twhile(line.charAt(0) === \\\" \\\") {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t}\\n\\t\\t// Save the modified line\\n\\t\\tlines[index] = line;\\n\\t}); \\n\\t// Stitch the replacement text together and set the selection\\n\\toperation.replacement = lines.join(\\\"\\\\n\\\");\\n\\tif(lines.length === 1) {\\n\\t\\toperation.newSelStart = operation.cutStart + operation.replacement.length;\\n\\t\\toperation.newSelEnd = operation.newSelStart;\\n\\t} else {\\n\\t\\toperation.newSelStart = operation.cutStart;\\n\\t\\toperation.newSelEnd = operation.newSelStart + operation.replacement.length;\\n\\t}\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"texteditoroperation\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/editor/operations/text/remove-tick.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/editor/operations/text/remove-tick.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/editor/operations/text/remove-tick.js\\ntype: application/javascript\\nmodule-type: texteditoroperation\\n\\nText editor operation to add a prefix to the selected lines\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports[\\\"remove-tick\\\"] = function(event,operation) {\\n\\tvar x = \\\"\\\";\\n\\tvar targetCount = parseInt(event.paramObject.count + \\\"\\\",10);\\n\\t// Cut just past the preceding line break, or the start of the text\\n\\toperation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);\\n\\t// Cut to just past the following line break, or to the end of the text\\n\\toperation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);\\n\\t// Compose the required prefix\\n\\tvar prefix = $tw.utils.repeat(event.paramObject.character,targetCount);\\n\\t// Process each line\\n\\tvar lines = operation.text.substring(operation.cutStart,operation.cutEnd).split(/\\\\r?\\\\n/mg);\\n\\t$tw.utils.each(lines,function(line,index) {\\n\\t\\t// Remove and count any existing prefix characters\\n\\t\\tvar count = 0;\\n\\t\\twhile(line.charAt(0) === event.paramObject.character) {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t\\tcount++;\\n\\t\\t\\tx += prefix;\\n\\t\\t}\\n\\t\\t// Remove any whitespace\\n\\t\\twhile(line.charAt(0) === \\\" \\\") {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t}\\n\\t\\t// We're done if we removed the exact required prefix, otherwise add it\\n\\t\\tif(x === \\\"\\\") {\\n\\t\\t\\twhile(line.charAt(0) === \\\" \\\") {\\n\\t\\t\\t\\tline = line.substring(1);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tline =  x.substring(1) + \\\" \\\" + line;\\n\\t\\t\\tx = \\\"\\\";\\n\\t\\t}\\n\\t\\t// Save the modified line\\n\\t\\tlines[index] = line;\\n\\t});\\n\\t// Stitch the replacement text together and set the selection\\n\\toperation.replacement = lines.join(\\\"\\\\n\\\");\\n\\tif(lines.length === 1) {\\n\\t\\toperation.newSelStart = operation.cutStart + operation.replacement.length;\\n\\t\\toperation.newSelEnd = operation.newSelStart;\\n\\t} else {\\n\\t\\toperation.newSelStart = operation.cutStart;\\n\\t\\toperation.newSelEnd = operation.newSelStart + operation.replacement.length;\\n\\t}\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"texteditoroperation\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/editor/operations/text/toggle-tick.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/editor/operations/text/toggle-tick.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/editor/operations/text/toggle-tick.js\\ntype: application/javascript\\nmodule-type: texteditoroperation\\n\\nText editor operation to add a prefix to the selected lines\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false exports:false */\\n\\\"use strict\\\";\\n\\nexports[\\\"toggle-tick\\\"] = function(event,operation) {\\n\\tvar targetCount = parseInt(event.paramObject.count + \\\"\\\",10);\\n\\t// Cut just past the preceding line break, or the start of the text\\n\\toperation.cutStart = $tw.utils.findPrecedingLineBreak(operation.text,operation.selStart);\\n\\t// Cut to just past the following line break, or to the end of the text\\n\\toperation.cutEnd = $tw.utils.findFollowingLineBreak(operation.text,operation.selEnd);\\n\\t// Compose the required prefix\\n\\tvar prefix = $tw.utils.repeat(event.paramObject.character,targetCount);\\n\\t// Process each line\\n\\tvar lines = operation.text.substring(operation.cutStart,operation.cutEnd).split(/\\\\r?\\\\n/mg);\\n\\t$tw.utils.each(lines,function(line,index) {\\n\\t\\t// Remove and count any existing prefix characters\\n\\t\\tvar addPrefix = true;\\n\\t\\tvar fragments = line.split(\\\" \\\");\\n\\t\\tif (fragments[0] === event.paramObject.character) {\\n\\t\\t\\tline = fragments.slice(1).join(\\\" \\\");\\n\\t\\t\\taddPrefix = false\\n\\t\\t} else {\\n\\t\\t\\tline = fragments.join(\\\" \\\");\\n\\t\\t}\\n\\t\\t// Remove any whitespace\\n\\t\\twhile(line.charAt(0) === \\\" \\\") {\\n\\t\\t\\tline = line.substring(1);\\n\\t\\t}\\n\\t\\t// We're done if we removed the exact required prefix, otherwise add it\\n\\t\\tif(addPrefix) {\\n\\t\\t\\t// Apply the prefix\\n\\t\\t\\tif (event.paramObject && event.paramObject.force === \\\"yes\\\") {\\n\\t\\t\\t\\tline = prefix + \\\" \\\" + line;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tline = (line === \\\"\\\") ? line : prefix + \\\" \\\" + line;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Save the modified line\\n\\t\\tlines[index] = line;\\n\\t}); \\n\\t// Stitch the replacement text together and set the selection\\n\\toperation.replacement = lines.join(\\\"\\\\n\\\");\\n\\tif(lines.length === 1) {\\n\\t\\toperation.newSelStart = operation.cutStart + operation.replacement.length;\\n\\t\\toperation.newSelEnd = operation.newSelStart;\\n\\t} else {\\n\\t\\toperation.newSelStart = operation.cutStart;\\n\\t\\toperation.newSelEnd = operation.newSelStart + operation.replacement.length;\\n\\t}\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"texteditoroperation\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/readme\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/readme\",\n            \"text\": \"Adds a possibilty to style text content with wikitext syntax\\n\\nIt's possible to manipulate the rules behaviour with: \\n\\n`\\\\rules only ticktext`\\n`\\\\rules excpet ticktext`\\n\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/parse-utils.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/parse-utils.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/parse-utils.js\\ntype: application/javascript\\nmodule-type: utils\\n\\nParse tree utility functions.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.addAttributeToParseTreeNodeXX = function(node,name,value) {\\n\\tnode.attributes = node.attributes || {};\\n\\tnode.attributes[name] = {type: \\\"string\\\", value: value};\\n};\\n\\nexports.getAttributeValueFromParseTreeNodeXX = function(node,name,defaultValue) {\\n\\tif(node.attributes && node.attributes[name] && node.attributes[name].value !== undefined) {\\n\\t\\treturn node.attributes[name].value;\\n\\t}\\n\\treturn defaultValue;\\n};\\n\\nexports.addClassToParseTreeNodeXX = function(node,classString) {\\n\\tvar classes = [];\\n\\tnode.attributes = node.attributes || {};\\n\\tnode.attributes[\\\"class\\\"] = node.attributes[\\\"class\\\"] || {type: \\\"string\\\", value: \\\"\\\"};\\n\\tif(node.attributes[\\\"class\\\"].type === \\\"string\\\") {\\n\\t\\tif(node.attributes[\\\"class\\\"].value !== \\\"\\\") {\\n\\t\\t\\tclasses = node.attributes[\\\"class\\\"].value.split(\\\" \\\");\\n\\t\\t}\\n\\t\\tif(classString !== \\\"\\\") {\\n\\t\\t\\t$tw.utils.pushTop(classes,classString.split(\\\" \\\"));\\n\\t\\t}\\n\\t\\tnode.attributes[\\\"class\\\"].value = classes.join(\\\" \\\");\\n\\t}\\n};\\n\\nexports.addStyleToParseTreeNodeXX = function(node,name,value) {\\n\\t\\tnode.attributes = node.attributes || {};\\n\\t\\tnode.attributes.style = node.attributes.style || {type: \\\"string\\\", value: \\\"\\\"};\\n\\t\\tif(node.attributes.style.type === \\\"string\\\") {\\n\\t\\t\\tnode.attributes.style.value += name + \\\":\\\" + value + \\\";\\\";\\n\\t\\t}\\n};\\n\\nexports.findParseTreeNodeXX = function(nodeArray,search) {\\n\\tfor(var t=0; t<nodeArray.length; t++) {\\n\\t\\tif(nodeArray[t].type === search.type && nodeArray[t].tag === search.tag) {\\n\\t\\t\\treturn nodeArray[t];\\n\\t\\t}\\n\\t}\\n\\treturn undefined;\\n};\\n\\n/*\\nHelper to get the text of a parse tree node or array of nodes\\n*/\\nexports.getParseTreeTextXX = function getParseTreeText(tree) {\\n\\tvar output = [];\\n\\tif($tw.utils.isArray(tree)) {\\n\\t\\t$tw.utils.each(tree,function(node) {\\n\\t\\t\\toutput.push(getParseTreeText(node));\\n\\t\\t});\\n\\t} else {\\n\\t\\tif(tree.type === \\\"text\\\") {\\n\\t\\t\\toutput.push(tree.text);\\n\\t\\t}\\n\\t\\tif(tree.children) {\\n\\t\\t\\treturn getParseTreeText(tree.children);\\n\\t\\t}\\n\\t}\\n\\treturn output.join(\\\"\\\");\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"utils\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/pragma-comment.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/pragma-comment.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/pragma-comment.js\\ntype: application/javascript\\nmodule-type: wikirule\\n\\nWiki pragma rule for pragma comment specifications\\n\\n```\\n\\\\\\\\ this is comment in pragma \\\"space\\\"\\n\\\\\\\\ fast comment, since it doesn't produce a parse-tree element\\n\\n\\\\\\\\define xx()\\n\\\\\\\\ slow comment because it WILL produce parse-tree elements\\n\\\\\\\\end\\n```\\n\\n\\\\*/\\n(function(){\\n/*jslint node: true, browser: true */\\n/*global $tw:false, exports:false*/\\n\\\"use strict\\\";\\n\\nexports.name = \\\"pragmacomment\\\";\\nexports.types = {\\n\\tpragma: true\\n};\\n\\n/*\\nInstantiate parse rule\\n*/\\nexports.init = function (parser) {\\n\\tvar self = this;\\n\\tthis.parser = parser;\\n\\t// Regexp to match\\n\\tthis.matchRegExp = /^\\\\\\\\\\\\\\\\/mg;\\n};\\n\\n/*\\nParse the most recent match\\n*/\\nexports.parse = function () {\\n\\t// Move past the pragma invocation\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// Parse line terminated by a line break\\n\\tvar reMatch = /([^\\\\n]*\\\\S)|(\\\\r?\\\\n)/mg;\\n\\n\\treMatch.lastIndex = this.parser.pos;\\n\\tvar match = reMatch.exec(this.parser.source);\\n\\twhile (match && match.index === this.parser.pos) {\\n\\t\\tthis.parser.pos = reMatch.lastIndex;\\n\\t\\t// Exit if we've got the line break\\n\\t\\tif (match[2]) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn [];\\n};\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikirule\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/customize.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/customize.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/customize.js\\ntype: application/javascript\\nmodule-type: wikirule\\n\\nWiki pragma rule for whitespace specifications\\n\\n```\\n\\\\customize tick=§ _element=div _endString= _mode= _classes= _use=\\n\\n\\\\customize angle=x _element=span _classes=.i.j.c.cp _endString=eee\\n\\n\\\\customize single=det _element=\\\"details\\\" _classes=\\\"\\\" _endString=\\\"—\\\"\\n\\n\\\\customize degree=sum _element=\\\"summary\\\"\\n\\n\\\\customize tick _element=span\\n```\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false, exports:false*/\\n\\\"use strict\\\";\\n\\nexports.name = \\\"customize\\\";\\nexports.types = {pragma: true};\\n\\nvar idTypes = [\\\"tick\\\", \\\"single\\\", \\\"degree\\\", \\\"angle\\\", \\\"almost\\\", \\\"pilcrow\\\", \\\"underscore\\\", \\\"little\\\", \\\"braille\\\", \\\"slash\\\"];\\n/*\\nInstantiate parse rule\\n*/\\nexports.init = function(parser) {\\n\\tvar self = this;\\n\\tthis.parser = parser;\\n\\t// Regexp to match\\n\\tthis.matchRegExp = /^\\\\\\\\customi[zs]e[^\\\\S\\\\n]/mg;\\n\\n\\tthis.p = this.parser;\\n\\tthis.p.configTickText = this.p.configTickText  || {};\\n\\t\\n\\tthis.pc = this.p.configTickText;\\n\\t\\n\\tidTypes.map( function(id) {\\n\\t\\tself.pc[id] = self.pc[id] || {};\\n\\t})\\n};\\n\\n\\n/* parse attributes\\nvar s = '<option value=\\\"\\\" data-foo=\\\"{{te st}}\\\" readonly>Value 1</option>';\\n\\nvar test_element = document.createElement('div');\\ntest_element.innerHTML = s;\\n\\nvar element = test_element.childNodes[0];\\nvar attributes = element.attributes;\\n\\nfor (var i = 0; i < attributes.length; i++) {\\n    var attribute = attributes[i];\\n\\n    console.log(attribute.name, '=>', attribute.value);\\n}\\n*/\\n\\nfunction parseAttributes(source) {\\n\\tvar pos = 0,\\n\\t\\tattributes= [];\\n\\n\\t// Process attributes\\n\\tvar attribute = $tw.utils.parseAttribute(source,pos);\\n\\twhile(attribute) {\\n\\t\\tattributes.push(attribute);\\n\\t\\tpos = attribute.end;\\n\\t\\t// Get the next attribute\\n\\t\\tattribute = $tw.utils.parseAttribute(source,pos);\\n\\t}\\n\\treturn attributes;\\n}\\n\\n/*\\nParse the most recent match\\n*/\\nexports.parse = function() {\\n\\t// Move past the pragma invocation\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// Parse line terminated by a line break\\n\\tvar reMatch = /([^\\\\n]*\\\\S)|(\\\\r?\\\\n)/mg,\\n\\t\\tline = \\\"\\\";\\n\\treMatch.lastIndex = this.parser.pos;\\n\\tvar match = reMatch.exec(this.parser.source);\\n\\twhile(match && match.index === this.parser.pos) {\\n\\t\\tthis.parser.pos = reMatch.lastIndex;\\n\\t\\t// Exit if we've got the line break\\n\\t\\tif(match[2]) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t// Process the token\\n\\t\\tif(match[1]) {\\n\\t\\t\\tline = (match[1]);\\n\\t\\t}\\n\\t\\t// Match the next token\\n\\t\\tmatch = reMatch.exec(this.parser.source);\\n\\t}\\n\\t\\n\\tvar attributes = parseAttributes(line);\\n\\n\\t// \\\\ticktext tick=x htmlTag=div params=\\\".i.j.c.cp\\\" end=\\\"eee\\\"\\n\\tvar id = \\\"X\\\", // There should be no id X!!\\n//\\t\\tconfigTickText = {_mode:\\\"\\\", _element:\\\"\\\", _classes:\\\"\\\", _endString:\\\"\\\"};\\n\\t\\tconfigTickText = {};\\n\\n\\tvar debugString = \\\"\\\\\\\\customize\\\";\\n\\t\\n\\t$tw.utils.each(attributes,function(token) {\\n\\t\\tswitch(token.name) {\\n\\t\\t\\tcase \\\"tick\\\": // fall through\\n\\t\\t\\tcase \\\"angle\\\": // fall through\\n\\t\\t\\tcase \\\"almost\\\": // fall through\\n\\t\\t\\tcase \\\"single\\\": // fall through\\n\\t\\t\\tcase \\\"degree\\\": // fall through\\n\\t\\t\\tcase \\\"pilcrow\\\":\\n\\t\\t\\tcase \\\"underscore\\\": // fall through\\n\\t\\t\\tcase \\\"little\\\": // fall through\\n\\t\\t\\tcase \\\"braille\\\": // fall through\\n\\t\\t\\tcase \\\"slash\\\": // fall through\\n\\t\\t\\t\\tid = token.name;\\n\\t\\t\\t\\tconfigTickText.symbol = token.value;\\n\\t\\t\\t\\tdebugString += \\\" \\\" + id + \\\"='\\\" + token.value + \\\"'\\\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"_params\\\": // falltrough\\n\\t\\t\\tcase \\\"_classes\\\":\\n\\t\\t\\tcase \\\"_debug\\\":\\n\\t\\t\\tcase \\\"_mode\\\":\\n\\t\\t\\tcase \\\"_element\\\":\\n\\t\\t\\tcase \\\"_classes\\\":\\n\\t\\t\\tcase \\\"_endString\\\":\\n\\t\\t\\tcase \\\"_use\\\":\\n\\t\\t\\tcase \\\"_useGlobal\\\":\\n\\t\\t\\tcase \\\"_srcName\\\":\\n\\t\\t\\t// case \\\"_1\\\": \\n\\t\\t\\t// case \\\"_2\\\": \\n\\t\\t\\t\\tconfigTickText[token.name] = token.value;\\n\\t\\t\\t\\tdebugString += \\\" \\\" + token.name + \\\"='\\\" + token.value + \\\"'\\\";\\n\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tconfigTickText[token.name] = token || {};\\n\\t\\t\\t\\tdebugString += \\\" \\\" + token.name + \\\"='\\\" + \\\"{..}\\\" + \\\"'\\\"; \\n\\t\\t}\\n\\t});\\n\\t\\n\\t// if _debug is set by _use in an other tiddler, we need the _debugString!\\n// \\tvar debugString = \\\"\\\\\\\\customize\\\";\\n// \\tObject.keys(configTickText).map( function(x) {\\n// \\t\\tif (x == \\\"symbol\\\") debugString += ' ' + id + '=\\\"' + configTickText[x] + '\\\"';\\n// \\t\\telse if (x == \\\"_debug\\\") debugString;\\n// \\t\\telse debugString += ' ' + x + '=\\\"' + \\\"{...}\\\" + '\\\"'; \\n// //\\t\\telse debugString += ' ' + x + '=\\\"' + JSON.stringify(configTickText[x], null, 2) + '\\\"'; \\n// \\t})\\n\\tconfigTickText._debugString = debugString;\\n\\n\\tthis.pc[id][configTickText.symbol] = configTickText;\\n\\t// No parse tree nodes to return\\n\\treturn [];\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikirule\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/pragmas/debug-customize.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/pragmas/debug-customize.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/pragmas/debug-customize.js\\ntype: application/javascript\\nmodule-type: wikirule\\n\\nReturns a JSON info of parser.configTickText\\n\\n```\\n\\\\debugcostomize\\n```\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false, exports:false*/\\n\\\"use strict\\\";\\n\\nexports.name = \\\"debugcustomize\\\";\\nexports.types = {pragma: true};\\n\\t\\nvar idTypes = [\\\"tick\\\", \\\"single\\\", \\\"degree\\\", \\\"angle\\\", \\\"almost\\\", \\\"pilcrow\\\", \\\"underscore\\\", \\\"little\\\", \\\"braille\\\", \\\"slash\\\"];\\n/*\\nInstantiate parse rule\\n*/\\nexports.init = function(parser) {\\n\\tvar self = this;\\n\\tthis.parser = parser;\\n\\t// Regexp to match\\n\\tthis.matchRegExp = /^\\\\\\\\debugcustomi[zs]e[^\\\\S\\\\n]/mg;\\n\\t\\n\\tthis.p = this.parser;\\n\\tthis.p.configTickText = this.p.configTickText  || {};\\n\\t\\n\\tthis.pc = this.p.configTickText;\\n\\t\\n\\tidTypes.map( function(id) {\\n\\t\\tself.pc[id] = self.pc[id] || {};\\n\\t})};\\n\\n/*\\nParse the most recent match\\n*/\\nexports.parse = function() {\\n\\tvar text = \\\"\\\";\\n\\t\\n\\t// Move past the pragma invocation\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// Parse line terminated by a line break\\n\\tvar reMatch = /(.*)\\\\r?\\\\n?|$/mg;\\n\\treMatch.lastIndex = this.parser.pos;\\n\\tvar match = reMatch.exec(this.parser.source);\\n\\tthis.parser.pos = reMatch.lastIndex;\\n\\n\\tvar config = this.pc,\\n\\t\\tglobal = this.p.wiki.caches[\\\"$:/config/custom-markup/pragma/PageTemplate\\\"].blockParseTree.configTickText,\\n\\t\\tfoundKey = false,\\n\\t\\ttest=[];\\n\\t\\n\\tif (match[0] === \\\"\\\" ) test = [\\\"\\\"]\\n\\telse test = (match[1]) ? match[1].split(/[ \\\\t]+/) : [\\\"\\\"];\\n\\n\\tif (test[0] === \\\"no\\\") {\\n\\t\\treturn [];\\n\\t} else if (test[0] === \\\"global\\\") {\\n\\t\\tif (test[1] === \\\"list\\\") {\\n\\t\\t\\ttext += \\\"global list:\\\\n\\\" \\n\\t\\t\\tObject.keys(global).map( function(el) {\\n\\t\\t\\t\\tvar x = Object.keys(global[el]);\\n\\t\\t\\t\\tif (x.length > 0) {\\n\\t\\t\\t\\t\\ttext += \\\"  - \\\" + el + \\\" {..}\\\\n\\\"\\n\\t\\t\\t\\t\\tfoundKey = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\ttext += (foundKey === false) ? \\\"  - no keys with values found!\\\" : \\\"\\\";\\n\\t\\t} else if (test[1]) {\\n\\t\\t\\ttext += \\\"global \\\" + test[1] + \\\":\\\\n\\\" + \\n\\t\\t\\tJSON.stringify(global[test[1]], null, 2)\\n\\t\\t} else {\\n\\t\\t\\ttext += \\\"global all:\\\\n\\\" + JSON.stringify(global, null, 2)\\n\\t\\t}\\n\\t\\ttext += \\\"\\\\n\\\"\\n\\t} else {\\n\\t\\tif (test[0] === \\\"list\\\") {\\n\\t\\t\\ttext += \\\"local list:\\\\n\\\" \\n\\t\\t\\tObject.keys(config).map( function(el) {\\n\\t\\t\\t\\tvar x = Object.keys(config[el]);\\n\\t\\t\\t\\tif (x.length > 0) {\\n\\t\\t\\t\\t\\tfoundKey = true;\\n\\t\\t\\t\\t\\ttext += \\\"  - \\\" + el + \\\" {..}\\\\n\\\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\ttext += (foundKey === false) ? \\\"  - no keys with values found!\\\" : \\\"\\\";\\n\\t\\t} else if (test[0] === \\\"all\\\" || test[0] === \\\"\\\") {\\n\\t\\t\\ttext += \\\"local all:\\\\n\\\" + JSON.stringify(config, null, 2)\\n\\t\\t} else {\\n\\t\\t\\ttext += \\\"local \\\" + test[0] + \\\":\\\\n\\\" + JSON.stringify(config[test[0]], null, 2)\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn [{\\n\\t\\ttype: \\\"codeblock\\\",\\n\\t\\tattributes: {\\n\\t\\t\\t\\tcode: {type: \\\"string\\\", value: text}\\n\\t\\t}\\n\\t}]\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikirule\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/pragmas/import-custom.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/pragmas/import-custom.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/pragmas/import-custom.js\\ntype: application/javascript\\nmodule-type: wikirule\\n\\nWiki pragma rule to import pragmas from other tiddlers\\n\\n```\\n\\\\importcustom [[pragma-global]] ... filter\\n```\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false, exports:false*/\\n\\\"use strict\\\";\\n\\nexports.name = \\\"importcustom\\\";\\nexports.types = {pragma: true};\\n\\nvar idTypes = [\\\"tick\\\", \\\"single\\\", \\\"degree\\\", \\\"angle\\\", \\\"almost\\\", \\\"pilcrow\\\", \\\"underscore\\\", \\\"little\\\", \\\"braille\\\", \\\"slash\\\"];\\n/*\\nInstantiate parse rule\\n*/\\nexports.init = function(parser) {\\n\\tvar self = this;\\n\\tthis.parser = parser;\\n\\t// Regexp to match\\n\\tthis.matchRegExp = /^\\\\\\\\importcustom[^\\\\S\\\\n]/mg;\\n\\t\\n\\tthis.p = this.parser;\\n\\tthis.p.configTickText = this.p.configTickText  || {};\\n\\t\\n\\tthis.pc = this.p.configTickText;\\n\\t\\n\\tidTypes.map( function(id) {\\n\\t\\tself.pc[id] = self.pc[id] || {};\\n\\t})\\n};\\n\\n/*\\nParse the most recent match\\n*/\\nexports.parse = function() {\\n\\tvar self = this,\\n\\t\\tfilter,\\n\\t\\ttiddlerList;\\n\\n\\t// Move past the pragma invocation\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// Parse line terminated by a line break\\n\\tvar reMatch = /(.*)\\\\r?\\\\n?|$/mg;\\n\\treMatch.lastIndex = this.parser.pos;\\n\\tvar match = reMatch.exec(this.parser.source);\\n\\tthis.parser.pos = reMatch.lastIndex;\\n\\t\\n\\tif (match) {\\n\\t\\tfilter = match[1];\\n\\t\\ttiddlerList = $tw.wiki.filterTiddlers(filter);\\n\\t}\\n\\n\\t$tw.utils.each(tiddlerList,function(title) {\\n\\t\\tvar pragmaInParser = $tw.wiki.parseText(\\\"text/vnd.tiddlywiki\\\", $tw.wiki.getTiddlerText(title));\\n\\t\\t\\n\\t\\tidTypes.map( function(id) {\\n\\t\\t\\tpragmaInParser.configTickText[id];\\n\\t\\t\\tObject.keys(pragmaInParser.configTickText[id]).map(function (key) {\\n\\t\\t\\t\\tpragmaInParser.configTickText[id][key].imported = true;\\n\\t\\t\\t})\\n\\t\\t\\t$tw.utils.extend(self.pc[id], pragmaInParser.configTickText[id]);\\n\\t\\t})\\n\\t});\\n\\n\\t// No parse tree nodes to return\\n\\treturn [];\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikirule\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/tickinline.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/tickinline.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/tickinline.js\\ntype: application/javascript\\nmodule-type: wikirule\\n\\nWiki text block rule for ticktext and angletext\\n\\nDetect\\n\\n´asdf.my.Class This is some text with a name and class\\n´.a.b.c.d This is some text with class\\n\\n»»»asdf.my.Class This is some text with a name and class\\n».a.b.c.d This is some text with class\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false exports:false */\\n\\\"use strict\\\";\\n\\nvar CLASS_GROUP = \\\"wltc\\\";\\nvar CLASS_PREFIX = CLASS_GROUP + \\\"-inline\\\"; \\n\\nexports.name = \\\"tickinline\\\";\\nexports.types = {inline: true};\\n\\t\\nvar idTypes = [\\\"underscore\\\", \\\"little\\\", \\\"braille\\\", \\\"slash\\\"];\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n\\n\\tvar self = this;\\n\\n\\t// Regexp to match \\n\\t// match[1] ... all symbols 1-4 ´ or » or ° or , or _\\n\\t// match[2] ... htmlTag ... default DIV\\n\\t// match[3] ... classString\\n//\\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›|(?=_[^_])_)((?:[^\\\\.\\\\r\\\\n\\\\s´°]+))?(\\\\.(?:[^\\\\r\\\\n\\\\s]+))?/mg; // OK\\n// \\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›|(?=_[^_])_)((?:[^\\\\.:\\\\r\\\\n\\\\s´°]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.6.x\\n//\\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›)((?:[^\\\\.:\\\\r\\\\n\\\\s]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.7.0\\n//\\tthis.matchRegExp = /((?=¶[^¶])¶|(?=﹙[^﹙])﹙|(?=⠒[^⠒])⠒|(?=__[^_])_)((?:[^\\\\.:\\\\r\\\\n\\\\s]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.7.1\\n\\tthis.matchRegExp = /((?=﹙[^﹙])﹙|(?=⠒[^⠒])⠒|(?=__[^_])__|(?=\\\\/°[^\\\\/°])\\\\/°)((?:[^\\\\.:\\\\r\\\\n\\\\s]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.7.1\\n\\t\\n\\tthis.p = this.parser;\\n\\tthis.p.configTickText = this.p.configTickText || {};\\n\\t\\n\\tthis.pc = this.p.configTickText;\\n\\n\\tidTypes.map( function(id) {\\n\\t\\tself.pc[id] = self.pc[id] || {};\\n\\t})\\n\\t\\n\\tthis.pc.X = {}; // There is a naming problem\\n};\\n\\n/*\\nParse the most recent match\\n*/\\nexports.parse = function() {\\n\\t/*\\n\\tSkip the endstring at the current position. Options are:\\n\\ttreatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace\\n\\t*/\\n\\tfunction skipEndString (endString) {\\n\\t\\tvar endRegExp = (endString instanceof RegExp) ? new RegExp(endString, \\\"mg\\\") : new RegExp(\\\"(\\\" + $tw.utils.escapeRegExp(endString) + \\\")\\\",\\\"mg\\\")\\n\\t\\tendRegExp.lastIndex = self.parser.pos;\\n\\t\\tvar endMatch = endRegExp.exec(self.parser.source);\\n\\t\\tif(endMatch && endMatch.index === self.parser.pos) {\\n\\t\\t\\tself.parser.pos = endRegExp.lastIndex;\\n\\t\\t}\\n\\t}\\n\\n//---------------------\\n\\tvar self = this,\\n\\t\\ttree = [],\\n\\t\\troot = [];\\n\\n\\t// Get all the details of the match\\n\\tvar id,\\n\\t\\tlevel    = (this.match[1]) ? this.match[1].length : 0,\\n\\t\\tsym      = this.match[2], // needs to be undefined if no match\\n\\t\\t_classes = (this.match[3]) ? this.match[3] : \\\"\\\",\\n\\t\\t_params  = (this.match[4]) ? this.match[4] : \\\"\\\";\\n\\n\\tvar useParagraph = false; // use paragraph by default\\n\\n\\t// global custom pragmas\\n\\tvar gPc = this.parser.wiki.caches[\\\"$:/config/custom-markup/pragma/PageTemplate\\\"].blockParseTree.configTickText;\\n\\n\\t// \\\"_debug\\\" is a binary parameter\\n\\tvar options = {symbol: sym, _mode : \\\"inline\\\", _element : (useParagraph) ? \\\"p\\\" : \\\"span\\\", _classes : _classes,\\n\\t\\t_endString : \\\"\\\", _use: \\\"\\\", _useGlobal: \\\"\\\", _debug: false, _debugString: \\\"\\\", _srcName:\\\"src\\\", _params : (_params !== \\\"\\\") ? _params.split(\\\":\\\") : [] };\\n\\n\\tswitch (this.match[1][0]) {\\n\\t\\tcase \\\"_\\\":\\n\\t\\t\\tid = \\\"underscore\\\";\\n\\t\\t\\toptions._element = \\\"u\\\"\\n\\t\\t\\toptions._endString = \\\"__\\\"\\n\\t\\tbreak;\\n\\t\\tcase \\\"﹙\\\":\\n\\t\\t\\tid = \\\"little\\\";\\n\\t\\t\\toptions._endString = \\\"﹚\\\"\\n\\t\\tbreak;\\n\\t\\tcase \\\"⠒\\\":\\n\\t\\t\\tid = \\\"braille\\\"\\n\\t\\t\\toptions._endString = \\\"⠶\\\"\\n\\t\\tbreak;\\n\\t\\tcase \\\"/\\\":\\n\\t\\t\\tid = \\\"slash\\\"\\n\\t\\t\\toptions._endString = \\\"°/\\\"\\n\\t\\tbreak;\\n\\t}\\n\\n\\tvar textEndInner,\\n\\t\\ttextStartInner,\\n\\t\\ttextEnd,\\n\\t\\ttextStart = this.parser.pos; // remember text postions for widget text handling\\n\\n\\t// Move past the start symbol\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t\\n\\tthis.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});\\n\\t// remember text postions for macro src handling\\n\\ttextStartInner = this.parser.pos\\n\\t// Parse any classes, whitespace and then the heading itself\\n\\tvar classes = _classes.split(\\\".\\\");\\n\\n\\tvar forceDebug = false,\\n\\t\\t_useError = false;\\n\\n\\tvar config = {};\\n\\n\\t// !!! The order of the checks is important!!! TODO make this nicer\\n\\tif (!sym && this.pc[id][\\\"true\\\"]) {\\n\\t// ID is locally defined\\n\\t\\tforceDebug = (this.pc[id][\\\"true\\\"]._debug) ? this.pc[id][\\\"true\\\"]._debug : false;\\n\\t\\tsym = (this.pc[id][\\\"true\\\"]._use) ? this.pc[id][\\\"true\\\"]._use : true;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t} else if (sym && this.pc[id][sym] && this.pc[id][sym]._use)  {\\n\\t\\t// ID and _use are locally defined\\n\\t\\tforceDebug = (this.pc[id][sym]._debug) ? this.pc[id][sym]._debug : false;\\n\\t\\tif ((sym === this.pc[id][sym]._use) && (this.pc[id][sym].imported !== true)) {\\n\\t\\t\\t// error Can't use itself\\n\\t\\t\\t_useError = \\\"Error - \\\\\\\\customize \\\" + id + \\\"=\\\" + sym + \\\" _use=\\\" + sym + \\\" is not possible!\\\";\\n\\t\\t\\tforceDebug = true;\\n\\t\\t}\\n\\t\\tsym = this.pc[id][sym]._use;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t} else if (sym && this.pc[id][sym] && this.pc[id][sym]._useGlobal && gPc[id][this.pc[id][sym]._useGlobal] )  {\\n\\t\\t// Use global symbol \\n\\t\\tforceDebug = (this.pc[id][sym]._debug) ? this.pc[id][sym]._debug : false;\\n\\t\\tsym = this.pc[id][sym]._useGlobal;\\n\\n\\t\\t// Switch to global configuration   TODO duplicated code\\n\\t\\tforceDebug = (forceDebug) ? forceDebug : (gPc[id][sym]._debug) ? gPc[id][sym]._debug : false;\\n\\t\\tconfig = gPc[id][sym];\\n\\t} else if (sym && this.pc[id][sym])  {\\n\\t\\t// Switch to local configuration\\n\\t\\tforceDebug = (this.pc[id][sym]._debug) ? this.pc[id][sym]._debug : false;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t} else if (sym && gPc[id][sym])  {\\n\\t\\t// Switch to global configuration\\n\\t\\tforceDebug = (gPc[id][sym]._debug) ? gPc[id][sym]._debug : false;\\n\\t\\tconfig = gPc[id][sym];\\n\\t} else if (sym !== \\\"\\\") {\\n\\t// Check if symbol is an HTML element\\n\\t\\toptions._element = ($tw.config.htmlBlockElements.indexOf(sym) !== -1) ? sym : options._element;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t}\\n\\n\\tif (config) {\\n\\t\\toptions.symbol = config.symbol || options.symbol;\\n\\t\\toptions._endString = config._endString || options._endString;\\n\\t\\toptions._mode = config._mode || options._mode;\\n\\t\\toptions._element = config._element || options._element;\\n\\t\\toptions._classes = config._classes || options._classes;\\n\\t\\t\\n\\t\\tif (forceDebug) options._debug = forceDebug;\\n\\t\\telse options._debug = config._debug || options._debug;\\n\\t\\t\\n\\t\\toptions._debugString = (_useError) ? _useError : config._debugString || options._debugString;\\n\\t\\toptions._srcName = config._srcName || options._srcName;\\n\\t\\toptions._1 = config._1 || options._1;\\n\\t\\toptions._2 = config._2 || options._2;\\n\\n\\t\\tvar xMaps = (config._params) ? config._params.split(\\\":\\\") : [\\\"\\\",\\\"\\\"];\\n\\t\\tvar lMaps = (options._params.length > 0 ) ? options._params : [\\\"\\\",\\\"\\\"];\\n\\n\\t\\toptions._params[1] = (lMaps[1]) ? lMaps[1] : xMaps[1];\\n\\t\\toptions._params[2] = (lMaps[2]) ? lMaps[2] : xMaps[2];\\n\\n\\t\\tclasses = (options._classes + _classes).split(\\\".\\\") // pragma _classes are added to tick _classes\\n//\\t\\tclasses[0] = options._classes.split(\\\".\\\").join(\\\" \\\").trim() // replace the name element\\n\\t}\\n\\t\\n// done in line 122\\n// \\tthis.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});\\n\\t\\n\\tvar oneBlock = false;\\n\\n\\tif ((options._mode === \\\"block\\\") ) { //&& (options._endString !== \\\"\\\")) {\\n\\t\\t// standard rendering\\n\\t\\t// no GROUP in block mode\\n\\t\\tclasses.push(CLASS_PREFIX);\\n\\n\\t\\tif (options._endString === \\\"\\\") {\\n\\t\\t\\toptions._endString = (useParagraph) ? \\\"\\\\\\\\r?\\\\\\\\n\\\\\\\\r?\\\\\\\\n\\\" : \\\"\\\\\\\\r?\\\\\\\\n\\\";\\n\\t\\t\\toneBlock = true;\\n\\t\\t} \\n\\n//\\t\\ttree = this.parser.parseBlocks(\\\"^\\\" + $tw.utils.escapeRegExp(options._endString) + \\\"$\\\");\\n//\\t\\ttree = this.parser.parseBlocks($tw.utils.escapeRegExp(options._endString));\\n\\t\\ttree = (oneBlock) ? this.parser.parseBlock(options._endString) : this.parser.parseBlocks(options._endString);\\n\\t} else {\\n\\t\\t// apply CLASS_GROUP only if in inline mode. \\n\\t\\tclasses.push(CLASS_PREFIX + \\\" \\\" + CLASS_GROUP);\\n\\n\\t\\tif (options._endString === \\\"\\\") {\\n//\\t\\t\\ttree = this.parser.parseInlineRun((useParagraph) ? /(\\\\r?\\\\n\\\\r?\\\\n)/mg : /(\\\\r?\\\\n)/mg, {eatTerminator:true}); \\n\\t\\t\\ttree = this.parser.parseInlineRun((useParagraph) ? /(\\\\r?\\\\n\\\\r?\\\\n)/mg : /(\\\\r?\\\\n)/mg);// OK for single new-line\\n\\t\\t} else {\\n//\\t\\t\\ttree = this.parser.parseInlineRun(new RegExp(\\\"(^\\\" + $tw.utils.escapeRegExp(options._endString) + \\\"$)\\\",\\\"mg\\\")); // V0.7.0\\n\\t\\t\\ttree = this.parser.parseInlineRun(new RegExp(\\\"(\\\" + $tw.utils.escapeRegExp(options._endString) + \\\")\\\",\\\"mg\\\"));\\n\\t\\t}\\n\\t}\\n\\t// remember text postions for macro src handling\\n\\ttextEndInner = this.parser.pos - options._endString.length;\\n\\n\\tskipEndString(options._endString);\\n\\t\\n\\ttextEnd = this.parser.pos;\\n\\n\\tvar attributes = {\\n\\t\\t\\t\\\"class\\\": {type: \\\"string\\\", value: classes.join(\\\" \\\").trim()}\\n\\t\\t}\\n\\t\\n\\tvar fixAttributes = [\\\"underscore\\\", \\\"little\\\", \\\"braille\\\", \\\"slash\\\", \\\"symbol\\\", \\n\\t\\t\\t\\t\\t\\t\\\"_endString\\\", \\\"_mode\\\", \\\"_element\\\", \\\"_classes\\\", \\\"_use\\\", \\\"_1\\\", \\\"_2\\\", \\\"_params\\\",\\n\\t\\t\\t\\t\\t\\t\\\"_srcName\\\", \\\"_debug\\\", \\\"_debugString\\\"];\\n\\n\\t// Callback is invoked with (element,title,object)\\n\\t$tw.utils.each(config, function(val,title,obj) {\\n\\t\\tif (fixAttributes.indexOf(title) === -1) {\\n\\t\\t\\tattributes[title] = obj[title];\\n\\t\\t\\t}\\n\\t});\\n\\n\\t// show tick config and code\\n\\tvar showRendered = true;\\n\\tif (options._debug) {\\n\\t\\tswitch (options._debug) {\\n\\t\\t\\tcase \\\"no\\\":\\n\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"both\\\":\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: options._debugString}}})\\n\\t\\t\\t\\tvar textOuter = this.parser.source.slice(textStart, textEnd);\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: textOuter}}})\\n\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"textOnly\\\":\\n\\t\\t\\t\\tshowRendered = false;\\n\\t\\t\\t\\t// intentional fall through\\n\\t\\t\\tcase \\\"text\\\":\\n\\t\\t\\t\\tvar textOuter = this.parser.source.slice(textStart, textEnd);\\n\\t//\\t\\t\\tvar textInner = this.parser.source.slice(textStartInner, textEndInner);\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: textOuter}}})\\n\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"pragmaOnly\\\":\\n\\t\\t\\t\\tshowRendered = false;\\n\\t\\t\\t\\t// intentional fall through\\n\\t\\t\\tcase \\\"pragma\\\": \\n\\t\\t\\t\\t// intentional fall through\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: options._debugString}}})\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (showRendered) {\\n\\t\\t// check if element is a widget\\n\\t\\tif (options._element[0] === \\\"$\\\") {\\n\\t//\\t\\tvar textOuter = this.parser.source.slice(textStart, textEnd);\\n\\t\\t\\tvar textInner = this.parser.source.slice(textStartInner, textEndInner);\\n\\t\\t\\tvar type = options._element.slice(1);\\n\\t\\t\\tvar maps = options._params,\\n\\t\\t\\t\\tml = maps.length,\\n\\t\\t\\t\\tx = \\\"\\\";\\n\\n\\t\\t\\tif (ml > 0) {\\n\\t\\t\\t\\tfor (var i=1; i <= ml; i++) {\\n\\t\\t\\t\\t\\tx = (maps[i] && options[\\\"_\\\"+i]) ? options[\\\"_\\\"+i].value : \\\"\\\";\\n\\t\\t\\t\\t\\tif (x) attributes[x] = {type: \\\"string\\\", value: maps[i]}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tattributes[options._srcName] = {type: \\\"string\\\", value: textInner}\\n\\t\\t\\troot.push({ type: type,\\n\\t\\t\\t\\t\\t\\ttag: options._element,\\n\\t\\t\\t\\t\\t\\tattributes: attributes,\\n\\t\\t\\t\\t\\t\\tchildren: tree})\\n\\t\\t} else {\\n\\t\\t\\troot.push( { type: \\\"element\\\", tag: options._element, attributes: attributes, children: tree});\\n\\t\\t}\\n\\t}\\n\\t// Return the paragraph\\n\\treturn root;\\n};\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikirule\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/tickinlineXXXX.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/tickinlineXXXX.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/tickinlineXXXX.js\\ntype: application/javascriptXXX\\nmodule-type: wikiruleXXX\\n\\nWiki text inline rule for assigning styles and classes to inline runs. For example:\\n\\n```\\n´´name.my.Class This is some text with a class´´\\n```\\n\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false exports:false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"tickinline\\\";\\nexports.types = {inline: true};\\n\\nvar idTypes = [\\\"inline\\\"];\\n\\nexports.init = function(parser) {\\n\\tvar self = this; \\n\\tthis.parser = parser;\\n\\t// Regexp to match\\n//\\tthis.matchRegExp = /°'(\\\\.(?:[^\\\\r\\\\n\\\\s]+))?/mg; // OK\\n//\\tthis.matchRegExp = /_((?:[^\\\\.:\\\\r\\\\n\\\\s_]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; \\n\\tthis.matchRegExp = /(__|\\\\/°|⠒|﹙)((?:[^\\\\.:\\\\r\\\\n\\\\s]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; \\n\\n\\tthis.p = this.parser;\\n\\tthis.p.configTickText = this.p.configTickText || {};\\n\\t\\n\\tthis.pc = this.p.configTickText;\\n\\n\\tidTypes.map( function(id) {\\n\\t\\tself.pc[id] = self.pc[id] || {};\\n\\t})\\n};\\n\\nexports.parse = function() {\\n\\tvar reEnd;\\n\\n\\tswitch (this.match[1]) {\\n\\t\\tcase \\\"__\\\":\\n\\t\\t\\treEnd = /___|_\\\\//g\\n\\t\\tbreak;\\n\\t\\tcase \\\"/°\\\":\\n\\t\\t\\treEnd = /°\\\\//g\\n\\t\\tbreak;\\n\\t\\tcase \\\"⠒\\\":\\n\\t\\t\\treEnd = /⠶/g\\n\\t\\tbreak;\\n\\t\\tcase \\\"﹙\\\":\\n\\t\\t\\treEnd = /﹚/g\\n\\t\\tbreak;\\n\\t}\\n\\n\\t// Get the styles and class\\n\\tvar\\t_sym = this.match[2] || \\\"\\\",\\n\\t\\t_classes = this.match[3] ? this.match[3].split(\\\".\\\").join(\\\" \\\") : \\\"\\\",\\n\\t\\t_params = this.match[4],\\n\\t\\t_element = \\\"span\\\";\\n\\n\\t// Move past the match\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// Parse the run up to the terminator\\n\\tvar tree = this.parser.parseInlineRun(reEnd,{eatTerminator: true});\\n\\n// \\\"_debug\\\" is a binary parameter\\n//\\tvar options = {symbol: sym, _mode : \\\"inline\\\", _element : \\\"span\\\", _classes : _classes, _endString : \\\"/°\\\", _use: \\\"\\\", _useGlobal: \\\"\\\",\\n//\\t\\t\\t\\t_debug: false, _debugString: \\\"\\\", _srcName:\\\"src\\\", _params : (_params !== \\\"\\\") ? _params.split(\\\":\\\") : [] };\\n\\n\\t// Return the classed span\\n\\tvar node = {\\n\\t\\ttype: \\\"element\\\",\\n\\t\\ttag: _element,\\n\\t\\tattributes: {\\n\\t\\t\\t\\\"class\\\": {type: \\\"string\\\", value: _classes + \\\" \\\" + \\\"wltc wltc-inline\\\"}\\n\\t\\t},\\n\\t\\tchildren: tree\\n\\t};\\n\\t// if(_classes) {\\n\\t// \\t$tw.utils.addClassToParseTreeNode(node,_classes);\\n\\t// }\\n\\t// if(_params) {\\n\\t// \\t$tw.utils.addAttributeToParseTreeNode(node,\\\"style\\\",_params);\\n\\t// }\\n\\treturn [node];\\n};\\n\\n})();\\n\",\n            \"type\": \"application/javascriptXXX\",\n            \"module-type\": \"wikiruleXXX\"\n        },\n        \"$:/plugins/wikilabs/custom-markup/wikirules/ticktext.js\": {\n            \"title\": \"$:/plugins/wikilabs/custom-markup/wikirules/ticktext.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/wikilabs/custom-markup/wikirules/ticktext.js\\ntype: application/javascript\\nmodule-type: wikirule\\n\\nWiki text block rule for ticktext and angletext\\n\\nDetect\\n\\n´asdf.my.Class This is some text with a name and class\\n´.a.b.c.d This is some text with class\\n\\n»»»asdf.my.Class This is some text with a name and class\\n».a.b.c.d This is some text with class\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw:false exports:false */\\n\\\"use strict\\\";\\n\\nvar CLASS_GROUP = \\\"wltc\\\";\\nvar CLASS_PREFIX = CLASS_GROUP + \\\"-l\\\"; // l .. level\\n\\nexports.name = \\\"ticktext\\\";\\nexports.types = {block: true};\\n\\t\\nvar idTypes = \\\"tick,single,degree,angle,almost,pilcrow\\\".split(\\\",\\\");\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n\\n\\tvar self = this;\\n\\n\\t// Regexp to match \\n\\t// match[1] ... all symbols 1-4 ´ or » or ° or , or _\\n\\t// match[2] ... htmlTag ... default DIV\\n\\t// match[3] ... classString\\n//\\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›|(?=_[^_])_)((?:[^\\\\.\\\\r\\\\n\\\\s´°]+))?(\\\\.(?:[^\\\\r\\\\n\\\\s]+))?/mg; // OK\\n// \\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›|(?=_[^_])_)((?:[^\\\\.:\\\\r\\\\n\\\\s´°]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.6.x\\n//\\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›)((?:[^\\\\.:\\\\r\\\\n\\\\s]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.7.0\\n\\tthis.matchRegExp = /((?=´[^´])´|[»≈]{1,4}|(?=°[^°])°|(?=›[^›])›|(?=¶[^¶])¶)((?:[^\\\\.:\\\\r\\\\n\\\\s]+))?(\\\\.(?:[^:\\\\r\\\\n\\\\s]+))?(\\\\:(?:[^.\\\\r\\\\n\\\\s]+))?/mg; // V0.7.1\\n\\t\\n\\tthis.p = this.parser;\\n\\tthis.p.configTickText = this.p.configTickText || {};\\n\\t\\n\\tthis.pc = this.p.configTickText;\\n\\n\\tidTypes.map( function(id) {\\n\\t\\tself.pc[id] = self.pc[id] || {};\\n\\t})\\n\\t\\n\\tthis.pc.X = {}; // There is a naming problem\\n};\\n\\n/*\\nParse the most recent match\\n*/\\nexports.parse = function() {\\n\\t/*\\n\\tSkip the endstring at the current position. Options are:\\n\\ttreatNewlinesAsNonWhitespace: true if newlines are NOT to be treated as whitespace\\n\\t*/\\n\\tfunction skipEndString (endString) {\\n\\t\\tvar endRegExp = (endString instanceof RegExp) ? new RegExp(endString, \\\"mg\\\") : new RegExp(\\\"(\\\" + $tw.utils.escapeRegExp(endString) + \\\")\\\",\\\"mg\\\")\\n\\t\\tendRegExp.lastIndex = self.parser.pos;\\n\\t\\tvar endMatch = endRegExp.exec(self.parser.source);\\n\\t\\tif(endMatch && endMatch.index === self.parser.pos) {\\n\\t\\t\\tself.parser.pos = endRegExp.lastIndex;\\n\\t\\t}\\n\\t}\\n\\n//---------------------\\n\\tvar self = this,\\n\\t\\ttree = [],\\n\\t\\troot = [];\\n\\n\\t// Get all the details of the match\\n\\tvar id,\\n\\t\\tlevel    = (this.match[1]) ? this.match[1].length : 0,\\n\\t\\tsym      = this.match[2], // needs to be undefined if no match\\n\\t\\t_classes = (this.match[3]) ? this.match[3] : \\\"\\\",\\n\\t\\t_params  = (this.match[4]) ? this.match[4] : \\\"\\\";\\n\\n\\tvar useParagraph = false; // use paragraph by default\\n\\n\\t// global custom pragmas\\n\\tvar gPc = this.parser.wiki.caches[\\\"$:/config/custom-markup/pragma/PageTemplate\\\"].blockParseTree.configTickText;\\n\\n\\tswitch (this.match[1][0]) {\\n\\t\\tcase \\\"»\\\":\\n\\t\\t\\tid = \\\"angle\\\";\\n\\t\\t\\tuseParagraph = true;\\n\\t\\tbreak;\\n\\t\\tcase \\\"≈\\\":\\n\\t\\t\\tid = \\\"almost\\\";\\n\\t\\t\\tuseParagraph = true;\\n\\t\\tbreak;\\n\\t\\tcase \\\"¶\\\":\\n\\t\\t\\tid = \\\"pilcrow\\\";\\n\\t\\t\\tuseParagraph = true;\\n\\t\\tbreak;\\n\\t\\tcase \\\"´\\\":\\n\\t\\t\\tid = \\\"tick\\\"\\n\\t\\tbreak;\\n\\t\\tcase \\\"›\\\":\\n\\t\\t\\tid = \\\"single\\\"\\n\\t\\tbreak;\\n\\t\\tcase \\\"°\\\":\\n\\t\\t\\tid = \\\"degree\\\"\\n\\t\\tbreak;\\n\\t}\\n\\n\\t// \\\"_debug\\\" is a binary parameter\\n\\tvar options = {symbol: sym, _mode : \\\"inline\\\", _element : (useParagraph) ? \\\"p\\\" : \\\"div\\\", _classes : _classes,\\n\\t\\t_endString : \\\"\\\", _use: \\\"\\\", _useGlobal: \\\"\\\", _debug: false, _debugString: \\\"\\\", _srcName:\\\"src\\\", _params : (_params !== \\\"\\\") ? _params.split(\\\":\\\") : [] };\\n\\n\\tvar textEndInner,\\n\\t\\ttextStartInner,\\n\\t\\ttextEnd,\\n\\t\\ttextStart = this.parser.pos; // remember text postions for widget text handling\\n\\n\\t// Move past the start symbol\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t\\n\\tthis.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});\\n\\t// remember text postions for macro src handling\\n\\ttextStartInner = this.parser.pos\\n\\t// Parse any classes, whitespace and then the heading itself\\n\\tvar classes = _classes.split(\\\".\\\");\\n\\n\\tvar forceDebug = false,\\n\\t\\t_useError = false;\\n\\n\\tvar config = {};\\n\\n\\t// !!! The order of the checks is important!!! TODO make this nicer\\n\\tif (!sym && this.pc[id][\\\"true\\\"]) {\\n\\t// ID is locally defined\\n\\t\\tforceDebug = (this.pc[id][\\\"true\\\"]._debug) ? this.pc[id][\\\"true\\\"]._debug : false;\\n\\t\\tsym = (this.pc[id][\\\"true\\\"]._use) ? this.pc[id][\\\"true\\\"]._use : true;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t} else if (sym && this.pc[id][sym] && this.pc[id][sym]._use)  {\\n\\t\\t// ID and _use are locally defined\\n\\t\\tforceDebug = (this.pc[id][sym]._debug) ? this.pc[id][sym]._debug : false;\\n\\t\\tif ((sym === this.pc[id][sym]._use) && (this.pc[id][sym].imported !== true)) {\\n\\t\\t\\t// error Can't use itself\\n\\t\\t\\t_useError = \\\"Error - \\\\\\\\customize \\\" + id + \\\"=\\\" + sym + \\\" _use=\\\" + sym + \\\" is not possible!\\\";\\n\\t\\t\\tforceDebug = true;\\n\\t\\t}\\n\\t\\tsym = this.pc[id][sym]._use;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t} else if (sym && this.pc[id][sym] && this.pc[id][sym]._useGlobal && gPc[id][this.pc[id][sym]._useGlobal] )  {\\n\\t\\t// Use global symbol \\n\\t\\tforceDebug = (this.pc[id][sym]._debug) ? this.pc[id][sym]._debug : false;\\n\\t\\tsym = this.pc[id][sym]._useGlobal;\\n\\n\\t\\t// Switch to global configuration   TODO duplicated code\\n\\t\\tforceDebug = (forceDebug) ? forceDebug : (gPc[id][sym]._debug) ? gPc[id][sym]._debug : false;\\n\\t\\tconfig = gPc[id][sym];\\n\\t} else if (sym && this.pc[id][sym])  {\\n\\t\\t// Switch to local configuration\\n\\t\\tforceDebug = (this.pc[id][sym]._debug) ? this.pc[id][sym]._debug : false;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t} else if (sym && gPc[id][sym])  {\\n\\t\\t// Switch to global configuration\\n\\t\\tforceDebug = (gPc[id][sym]._debug) ? gPc[id][sym]._debug : false;\\n\\t\\tconfig = gPc[id][sym];\\n\\t} else if (sym !== \\\"\\\") {\\n\\t// Check if symbol is an HTML element\\n\\t\\toptions._element = ($tw.config.htmlBlockElements.indexOf(sym) !== -1) ? sym : options._element;\\n\\t\\tconfig = this.pc[id][sym];\\n\\t}\\n\\n\\tif (config) {\\n\\t\\toptions.symbol = config.symbol || options.symbol;\\n\\t\\toptions._endString = config._endString || options._endString;\\n\\t\\toptions._mode = config._mode || options._mode;\\n\\t\\toptions._element = config._element || options._element;\\n\\t\\toptions._classes = config._classes || options._classes;\\n\\t\\t\\n\\t\\tif (forceDebug) options._debug = forceDebug;\\n\\t\\telse options._debug = config._debug || options._debug;\\n\\t\\t\\n\\t\\toptions._debugString = (_useError) ? _useError : config._debugString || options._debugString;\\n\\t\\toptions._srcName = config._srcName || options._srcName;\\n\\t\\toptions._1 = config._1 || options._1;\\n\\t\\toptions._2 = config._2 || options._2;\\n\\n\\t\\tvar xMaps = (config._params) ? config._params.split(\\\":\\\") : [\\\"\\\",\\\"\\\"];\\n\\t\\tvar lMaps = (options._params.length > 0 ) ? options._params : [\\\"\\\",\\\"\\\"];\\n\\n\\t\\toptions._params[1] = (lMaps[1]) ? lMaps[1] : xMaps[1];\\n\\t\\toptions._params[2] = (lMaps[2]) ? lMaps[2] : xMaps[2];\\n\\n\\t\\tclasses = (options._classes + _classes).split(\\\".\\\") // pragma _classes are added to tick _classes\\n//\\t\\tclasses[0] = options._classes.split(\\\".\\\").join(\\\" \\\").trim() // replace the name element\\n\\t}\\n\\t\\n// done in line 122\\n// \\tthis.parser.skipWhitespace({treatNewlinesAsNonWhitespace: true});\\n\\t\\n\\tvar oneBlock = false;\\n\\n\\tif ((options._mode === \\\"block\\\") ) { //&& (options._endString !== \\\"\\\")) {\\n\\t// standard rendering\\n\\t\\t// no GROUP in block mode\\n\\t\\tclasses.push(CLASS_PREFIX + level);\\n\\n\\t\\tif (options._endString === \\\"\\\") {\\n\\t\\t\\toptions._endString = (useParagraph) ? \\\"\\\\\\\\r?\\\\\\\\n\\\\\\\\r?\\\\\\\\n\\\" : \\\"\\\\\\\\r?\\\\\\\\n\\\";\\n\\t\\t\\toneBlock = true;\\n\\t\\t} \\n\\n//\\t\\ttree = this.parser.parseBlocks(\\\"^\\\" + $tw.utils.escapeRegExp(options._endString) + \\\"$\\\");\\n//\\t\\ttree = this.parser.parseBlocks($tw.utils.escapeRegExp(options._endString));\\n\\t\\ttree = (oneBlock) ? this.parser.parseBlock(options._endString) : this.parser.parseBlocks(options._endString);\\n\\t} else {\\n\\t\\t// apply CLASS_GROUP only if in inline mode. \\n\\t\\tclasses.push(CLASS_PREFIX + level + \\\" \\\" + CLASS_GROUP);\\n\\n\\t\\tif (options._endString === \\\"\\\") {\\n//\\t\\t\\ttree = this.parser.parseInlineRun((useParagraph) ? /(\\\\r?\\\\n\\\\r?\\\\n)/mg : /(\\\\r?\\\\n)/mg, {eatTerminator:true}); \\n\\t\\t\\ttree = this.parser.parseInlineRun((useParagraph) ? /(\\\\r?\\\\n\\\\r?\\\\n)/mg : /(\\\\r?\\\\n)/mg);// OK for single new-line\\n\\t\\t} else {\\n//\\t\\t\\ttree = this.parser.parseInlineRun(new RegExp(\\\"(^\\\" + $tw.utils.escapeRegExp(options._endString) + \\\"$)\\\",\\\"mg\\\")); // V0.7.0\\n\\t\\t\\ttree = this.parser.parseInlineRun(new RegExp(\\\"(\\\" + $tw.utils.escapeRegExp(options._endString) + \\\"$)\\\",\\\"mg\\\"));\\n\\t\\t}\\n\\t}\\n\\t// remember text postions for macro src handling\\n\\ttextEndInner = this.parser.pos - options._endString.length;\\n\\n\\tskipEndString(options._endString);\\n\\t\\n\\ttextEnd = this.parser.pos;\\n\\n\\tvar attributes = {\\n\\t\\t\\t\\\"class\\\": {type: \\\"string\\\", value: classes.join(\\\" \\\").trim()}\\n\\t\\t}\\n\\t\\n\\tvar fixAttributes = [\\\"pilcrow\\\", \\\"tick\\\", \\\"angle\\\", \\\"almost\\\", \\\"single\\\", \\\"degree\\\", \\\"symbol\\\", \\n\\t\\t\\t\\t\\t\\t\\\"_endString\\\", \\\"_mode\\\", \\\"_element\\\", \\\"_classes\\\", \\\"_use\\\", \\\"_1\\\", \\\"_2\\\", \\\"_params\\\",\\n\\t\\t\\t\\t\\t\\t\\\"_srcName\\\", \\\"_debug\\\", \\\"_debugString\\\"];\\n\\n\\t// Callback is invoked with (element,title,object)\\n\\t$tw.utils.each(config, function(val,title,obj) {\\n\\t\\tif (fixAttributes.indexOf(title) === -1) {\\n\\t\\t\\tattributes[title] = obj[title];\\n\\t\\t\\t}\\n\\t});\\n\\n\\t// show tick config and code\\n\\tvar showRendered = true;\\n\\tif (options._debug) {\\n\\t\\tswitch (options._debug) {\\n\\t\\t\\tcase \\\"no\\\":\\n\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"both\\\":\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: options._debugString}}})\\n\\t\\t\\t\\tvar textOuter = this.parser.source.slice(textStart, textEnd);\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: textOuter}}})\\n\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"textOnly\\\":\\n\\t\\t\\t\\tshowRendered = false;\\n\\t\\t\\t\\t// intentional fall through\\n\\t\\t\\tcase \\\"text\\\":\\n\\t\\t\\t\\tvar textOuter = this.parser.source.slice(textStart, textEnd);\\n\\t//\\t\\t\\tvar textInner = this.parser.source.slice(textStartInner, textEndInner);\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: textOuter}}})\\n\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"pragmaOnly\\\":\\n\\t\\t\\t\\tshowRendered = false;\\n\\t\\t\\t\\t// intentional fall through\\n\\t\\t\\tcase \\\"pragma\\\": \\n\\t\\t\\t\\t// intentional fall through\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\troot.push({type:\\\"codeblock\\\", attributes:{ code: {type:\\\"string\\\", value: options._debugString}}})\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (showRendered) {\\n\\t\\t// check if element is a widget\\n\\t\\tif (options._element[0] === \\\"$\\\") {\\n\\t//\\t\\tvar textOuter = this.parser.source.slice(textStart, textEnd);\\n\\t\\t\\tvar textInner = this.parser.source.slice(textStartInner, textEndInner);\\n\\t\\t\\tvar type = options._element.slice(1);\\n\\t\\t\\tvar maps = options._params,\\n\\t\\t\\t\\tml = maps.length,\\n\\t\\t\\t\\tx = \\\"\\\";\\n\\n\\t\\t\\tif (ml > 0) {\\n\\t\\t\\t\\tfor (var i=1; i <= ml; i++) {\\n\\t\\t\\t\\t\\tx = (maps[i] && options[\\\"_\\\"+i]) ? options[\\\"_\\\"+i].value : \\\"\\\";\\n\\t\\t\\t\\t\\tif (x) attributes[x] = {type: \\\"string\\\", value: maps[i]}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tattributes[options._srcName] = {type: \\\"string\\\", value: textInner}\\n\\t\\t\\troot.push({ type: type,\\n\\t\\t\\t\\t\\t\\ttag: options._element,\\n\\t\\t\\t\\t\\t\\tattributes: attributes,\\n\\t\\t\\t\\t\\t\\tchildren: tree})\\n\\t\\t} else {\\n\\t\\t\\troot.push( { type: \\\"element\\\", tag: options._element, attributes: attributes, children: tree});\\n\\t\\t}\\n\\t}\\n\\t// Return the paragraph\\n\\treturn root;\\n};\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"wikirule\"\n        }\n    }\n}"}